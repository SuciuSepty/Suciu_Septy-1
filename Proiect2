import hashlib
import string
import sys

# Hash-ul parolei reale
target_hash = "0e000d61c1735636f56154f30046be93b3d71f1abbac3cd9e3f80093fdb357ad"

# Definim seturile de caractere pentru fiecare categorie
lowercase = string.ascii_lowercase  # a-z
uppercase = string.ascii_uppercase  # A-Z
digits = string.digits              # 0-9
specials = "!@#$"                   # caractere speciale

# Pentru a opri recursivitatea la timp
gasit = False
apeluri_recursive = 0

def get_hash(password):
    return hashlib.sha256(password.encode()).hexdigest()

def valid_combination(candidate):
    upper = sum(1 for c in candidate if c in uppercase)
    digit = sum(1 for c in candidate if c in digits)
    special = sum(1 for c in candidate if c in specials)
    lower = sum(1 for c in candidate if c in lowercase)
    return upper == 1 and digit == 1 and special == 1 and lower == 3

def backtrack(candidate):
    global gasit, apeluri_recursive
    apeluri_recursive += 1

    if gasit:
        return

    if len(candidate) == 6:
        if valid_combination(candidate):
            password = "".join(candidate)
            if get_hash(password) == target_hash:
                gasit = True
                print(f"Parola găsită: {password}")
                print(f"Număr apeluri recursive: {apeluri_recursive}")
                sys.exit(0)  # oprim imediat
        return

    # Alegem caractere doar dacă nu s-a găsit parola
    for char_set in (lowercase, uppercase, digits, specials):
        for char in char_set:
            if gasit:
                return
            backtrack(candidate + [char])

# Pornim algoritmul
backtrack([])

print("Parola nu a fost găsită.")
